%-*-coding: utf-8-*-
\chapter{Оптимизация Rake-Compress деревьев}

В отличие от предыдущей главы, в данной главе рассматриваются деревья, у которых нет ограничения на степени вершин. 
В данной главе показаны новые методы, которые позволяют избавиться от этого ограничения, не увеличивая при этом время работы.
Также в главе рассмотрены идеи, которые позволяют существенно уменьшить константу времени работы и потребляемой памяти.
Кроме того, в данной главе показано, как можно использовать Rake-Compress деревья для пересчета функций на поддеревьях.

\FloatBarrier
\section{Определение и пересчет изменившихся клеток}
В разделе~\ref{sec:changed} показано как находить клетки, которые поменялись в случае наличия ограничения на степени вершин дерева.
Существенное отличие заключается в том, что в общем случае нельзя проверить, изменились ли соседние вершины, так как их число может быть равно $\Omega(n)$.
Рассмотрим две таблицы Rake-Compress деревьев для графов, которые отличаются одним ребром. Определим, чем отличаются эти таблицы.

Во-первых, отличаются клетки, которые соответствуют концам измененного ребра. 
Если же вершина не является концом ребра, то она будет считаться поменявшейся только в случае, если поменялось множество ее детей или родитель. 
А это может произойти только в том случае, если ее ребенком или родителем является поменявшаяся вершина и она сжалась к родителю хотя бы в одной из версий Rake-Compress таблицы.

Поэтому для каждой поменявшейся вершины будем следить, что с ней происходит в обоих версиях таблицы. 
Когда вершина сжимается к родителю, у нее не может быть более двух смежных вершин (включая родителя).
Значит, когда в какой-то из версий вершина удаляется, к множеству поменявшихся вершин нужно добавить $O(1)$ новых вершин.
Проблема заключается в том, что необходимо не только понять, что клетка поменялась, но и найти ее правильное состояние. 

Рассмотрим, например, случай, когда в <<старой>> версии таблицы вершина $v$ сжалась к вершине $p$, имея при этом единственного ребенка $c$: 
из множества детей вершины $p$ удалилась $v$, и добавилась $c$, а новым родителем вершины $c$ стала вершина $p$. 
Если в <<новой>> версии такого сжатия не произошло, то необходимо вернуть все обратно --- из множества детей вершины $p$ удалить $c$ и добавить $v$, а родителем вершины $c$ назначить $p$.
Основная проблема заключается в том, что данные изменения необходимо сделать со всеми клетками, которые соответствуют вершинам $p$ и $c$ в более поздние моменты времени. А их может быть $\Omega(\log n)$.

Всего необходимо рассмотреть четыре случая (в зависимости от того, сжалась ли вершина в каждой из двух версий таблицы). 
В каждом таком случае необходимо отдельно обработать случаи, когда вершина является листом (у нее нет детей) или является корнем (у нее нет родителя).
Таким образом, рассмотрев большое количество случаев, можно получить алгоритм, 
который обрабатывает одно добавление или удаление ребра за время $O(\log^2 n)$, 
так как изменившихся клеток $O(\log n)$, а обработка каждой клетки занимает $O(\log n)$ времени (при условии, что добавление и удаление из множества детей происходит за $O(1)$).
\FloatBarrier
\section{Оптимизация памяти}
\label{sec:memory}

В разделе \ref{sec:tree_storage} говорилось, что Rake-Compress дерево принято хранить в виде таблице из $O(\log n)$ строк и $n$ столбцов. 
Суммарное количество непустых клеток $O(n)$, однако, их хранение с помощью ассоциативного массива, хоть и уменьшает асимптотику до $O(n)$, значительно увеличивает константу времени работы.
Поэтому на практике такой подход не используется. 

Предлагаемая оптимизация заключается в том, чтобы хранить таблицу по столбцам, а не по строкам. Каждый столбец соответствует некоторой вершине.
Заметим, что каждая вершина жива только первые несколько применений операций Rake и Compress. Если же в какой-то момент вершина была сжата к своему родителю, то далее она перестает быть живой.

Также следует отметить, что в случае изменения структуры леса, который хранится в Rake-Compress дереве, обращение часто происходит к клеткам из одного столбца. 
Если хранить дерево предложенным способом, эти обращения будут происходить к последовательным участкам памяти, что может положительно сказаться на производительности.

\FloatBarrier
\section{Хранение множества детей}
\label{sec:set_storage}

Рассмотрим более подробно, какие операции должна поддерживать структура данных, которая хранит в каждой клетке текущее множество детей вершины.
Ранее уже говорилось, что она должна поддерживать удаление и добавление элементов за $O(1)$. 
На самом деле, множество детей хранится для того, чтобы определять, можно ли сжать вершину. Если детей у вершины больше одного, то ее точно нельзя сжать.
Если у нее нет детей, то ее можно сжать только во время операции Rake. Интересным является случай, когда у вершины ровно один ребенок. Тогда, чтобы определить 
можно ли применить операцию Compress к вершине, нужно узнать, какой бит был сгенерирован на текущей итерации для ребенка. А для этого необходимо знать номер вершины-ребенка.
Значит, необходимо уметь определять, кто находится в множестве только в том случае, если в нем не более одного элемента.

Поэтому всю информацию о множестве можно хранить всего с помощью двух величин. А именно, можно хранить количество элементов в множестве и сумму их номеров. 
Тогда для добавления вершины в множество необходимо увеличить счетчик количества вершин, а также добавить к сумме номер вершины. 
Для удаления вершины из множества необходимо уменьшить счетчик количества вершин, и вычесть номер вершины из суммы. 
А когда в множестве останется ровно один элемент, то его номер будет равен сумме номеров всех элементов.

Данная оптимизация позволяет существенно уменьшить константу времени работы и используемой памяти. 

\FloatBarrier
\section{Пересчет состояний вершин в таблице Rake-Compress дерева}

Рассмотрим более подробно тонкости реализации Rake-Compress деревьев. В каждой клетке таблицы хранится состояние вершины в некоторый момент времени. 
В состояние вершины входит ее родитель, а также множество детей, которое хранится в виде суммы их номеров и их количества. Также будем запоминать, 
как изменяется состояние при переходе к следующему слою. А именно, будем хранить, кто должен стать новым родителем, на сколько изменится количество детей, а также как изменится сумма их номеров. 
Все это необходимо для того, чтобы обрабатывать каждую изменившуюся клетку за $O(1)$. 

Как только некоторая вершина помечается как изменившаяся, отменим ее действие на таблицу. 
Найдем момент времени, когда вершина сжимается к родителю (если хранить таблицу по столбцам, это можно сделать за $O(1)$).
Рассмотрим, какие вершины поменяются при сжатии данной. Это ее родитель (если он есть), а также сын (если он есть).
Для каждой из этих вершин поменяем значения изменений, которые необходимо применить к состоянию. 
Также пометим, что эти вершины поменялись на этом слое. Для этого на каждом слое будем хранить список вершин, которые на нем поменялись. 
А перед тем как обрабатывать очередной слой будем добавлять в множество изменившихся вершин вершины из соответствующего списка. 

При этом необходимо удостоверится, что вершина еще не находится в множестве. 
Это можно сделать простых проходом по всему множеству (так как математическое ожидание количества вершин в нем равно константе).
Однако, есть и более эффективный с практической точки зрения метод. Будем считать, что к структуре данных поступают запросы о добавлении и удалении ребер. 
Тогда для каждой вершины будем запоминать номер последнего запроса, в котором вершина была помечена изменившейся. 
В таком случае можно будет узнать, лежит ли вершина в множестве изменившихся за одно обращение к массиву.

Кроме удаления эффекта от изменившихся вершин также необходимо и добавить правильный эффект. 
Для этого будем для каждой из изменившихся вершин определять, как ее состояние меняется при переходе к следующему слою.
Если вершина сжимается к ее родителю, то пометим родителя и ребенка (если он есть) и поменяем изменение, которое хранится в соответствующих клетках. 
А для пересчета состояния клеток воспользуемся значениями изменений, которые сохранены в клетках.
  
Таким образом, хранение изменений, которые должны произойти с клеткой при переходе к следующему слою, позволяет уменьшить время обработки одного запроса до $O(\log n)$. 

Реализация динамических Rake-Compress деревьев на языке программирования Java доступна в \cite{github}.

\FloatBarrier
\section{Случай неориентированного дерева}
\label{sec:undirected}

Ранее был рассмотрен только случай корневых деревьев, однако Rake-Compress деревья можно строить и в неориентированном случае.
Операция Rake по-прежнему удаляет все листья дерева. Операция Compress применяется к вершинам, у которых ровно две смежные вершины. 
Предложенная оптимизация памяти также применима. А чтобы хранить множество вершин, необходимо приложить чуть больше усилий.

Отличие неориентированного случая заключается в том, что необходимо узнавать номера смежных вершин в случае, когда их становится не больше двух. 
А, значит, хранить только сумму их номеров недостаточно. Поэтому предлагается кроме этого хранить сумму квадратов их номеров. Тогда, чтобы узнать, 
какие вершины принадлежат множеству необходимо решить квадратное уравнение.

\FloatBarrier
\section{Пересчет аддитивных функций}

Кроме запросов о структуре леса, Rake-Compress деревья можно использовать для подсчета значений некоторых функций. 
Например, каждой вершине можно сопоставить некоторое значение и узнать, чему равна сумма значений всех вершин, которые находятся в поддереве.

Для этого в клетках таблицы Rake-Compress дерева необходимо хранить не только состояние вершины, но и значение функции, посчитанной на части дерева, которое уже было сжато в вершину. 
Если функция является аддитивной, то ее пересчет аналогичен пересчету множества детей вершины. 
Так, если некоторая вершина сжимается к родителю, то в соответствующей родителю клетке необходимо обновить значение функции. 
При добавлении и удалении ребер необходимо в изменившихся клетках пересчитывать значение функции. 
Аддитивность функции позволяет нам отменять сжатие вершины к своему родителю за $O(1)$. Поэтому общее время работы не изменится и будет составлять $O(\log n)$ на одно обновление.

Заметим также, что как и в случае с множеством детей, в каждой клетке необходимо хранить, как изменяется функция при переходе к следующему слою.

\FloatBarrier
\section{Пересчет ассоциативных функций}

Если же необходимо считать значение функции, которая не является аддитивной, то можно воспользоваться следующим методом.
В каждой клетке можно хранить все изменения функции, которые произошли из-за сжатия детей в виде сбалансированного двоичного дерева. 
Тогда при изменении множества детей необходимо соответствующим образом изменить дерево. 
Это приведет к тому, что в худшем случае пересчет таблицы Rake-Compress дерева при добавлении или удаления одного ребра будет работать за $\Theta(\log^2 n)$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End: